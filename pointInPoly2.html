<!-- works without stuttering -->

<!doctype html>
<meta charset="utf-8">
<html>
  <head>
    <style type="text/css">
      #canvas {
        width: 800px;
        height: 400px;
        border: 1px solid #666;
      }
      path {
        fill: none;
        stroke-width: 1px;
        stroke: #666;
      }
      circle {
        fill: steelblue;
      }
      circle.selected {
        fill: #ff0000;
      }

      .q0-9{fill:rgb(247,251,255)}
      .q1-9{fill:rgb(222,235,247)}
      .q2-9{fill:rgb(198,219,239)}
      .q3-9{fill:rgb(158,202,225)}
      .q4-9{fill:rgb(107,174,214)}
      .q5-9{fill:rgb(66,146,198)}
      .q6-9{fill:rgb(33,113,181)}
      .q7-9{fill:rgb(8,81,156)}
      .q8-9{fill:rgb(8,48,107)}
    </style>
  </head>

  <body>

    <div id="canvas"></div>


    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script>
      var copy,
        coords = [],
        width = 800,
        height = 400,
        margin = 50;

      var trans = [0,0];

      drag = d3.behavior.drag()
                .origin(Object)
                .on("drag", function(d){
                  trans = [d3.mouse(this)[0], d3.mouse(this)[1]];
                  draw();
                });

      // zoom = d3.behavior.zoom()
      //           .on("zoom", function(d){
      //             trans = [d3.event.translate[0], d3.event.translate[1]];
      //             console.log(trans);
      //             draw();
      //           });

      svg = d3.select("#canvas").append("svg").attr({
              width: width,
              height: height
            });

       g = svg.append("g")
            .call(drag);
            // .call(zoom);

      var grid = {width: 160, height: 120};
      grid.cols = 960 / grid.width, 
      grid.rows = 500 / grid.height;

      data = {};
      data['type'] ='FeatureCollection';
      data['features'] = [];
      for (var r = 0; r < grid.rows; r++) {
          for (var c = 0; c < grid.cols; c++) {
            var coords = {"type": "Feature", "geometry":{"type": "Polygon", "coordinates": [[
            [c * grid.width, r * grid.width],
            [c * grid.width, (r+1) * grid.width],
            [(c+1) * grid.width, (r+1) * grid.width],
            [(c+1)* grid.width, r * grid.width],
            [c* grid.width, r * grid.width]]
            ]
          }}
          data.features.push(coords);
          }
      };
     

      // from https://github.com/substack/point-in-polygon
      var pointInPolygon = function (point, vs, offset) {
        // ray-casting algorithm based on
        // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
        var xi, xj, i, intersect,
            x = point[0],
            y = point[1],
            inside = false;
        for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
          xi = vs[i][0]+offset[0],
          yi = vs[i][1]+offset[1],
          xj = vs[j][0]+offset[0],
          yj = vs[j][1]+offset[1],
          intersect = ((yi > y) != (yj > y))
              && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      },

     
      randPoint = function(min, max) {
        return Math.floor(Math.random() * (max-min)) + min;
      },

      points = function(numPoints) {
        var data = [];
        for (i=0; i < numPoints; i++) {
          data.push({x: randPoint(margin, width-margin), y: randPoint(margin, height-margin)});
        }
        return data;
      };


      var calculator = function(circles, polygon, initial){
        var eachpoly = 0;
          // console.log(polygon.geometry.coordinates[0]);
          for (j=0; j<circles.length; j++){
            if (pointInPolygon([circles[j].x, circles[j].y], polygon.geometry.coordinates[0], initial)){
              eachpoly += 1;
            }
          }
          col = "q" + Math.min(8, ~~(eachpoly * 9 / 100)) + "-9";
          return col;
      };

  var trialpoints = points(1000);

  grids = g.selectAll("polygon")
          .data(data.features)
          .enter().append("polygon")
          .style("stroke", "grey")
          .attr("points", function(d){
            return d.geometry.coordinates.map(function(d){
              return d.join(" ")})});
          

 dot = g.selectAll("circle")
      .data(trialpoints)
    .enter().append("circle")
      .attr({
        cx: function(d, i) {
          return d.x;
        },
        cy: function(d, i) {
          return d.y;
        },
        r: 3
      })
      .classed("selected", false);

function draw() {
        grids.attr("transform", function(d) { 
          return "translate("+ trans[0] + "," + trans[1] +")"})
        .attr("class", function(d){
            return calculator(trialpoints, d, trans)});
}

draw();








    </script>

  </body>
</html>